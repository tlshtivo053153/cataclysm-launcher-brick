### MOD管理機能の修正計画

#### 1. MOD有効化時のエラー修正

**問題:**
`Available Mods`ペインでMODを有効化する際、すでにシンボリックリンクが存在する場合でもリンクを作成しようとして `already exists (File exists)` エラーが発生しています。

**解決策:**
`ModHandler.hs` の `enableMod` 関数を修正し、シンボリックリンクを作成する前に、リンク先のパスにファイルやリンクが既に存在するかどうかをチェックします。存在する場合は、何もしせずに成功として処理を完了させます。これにより、この操作の冪等性（何度実行しても同じ結果になること）を保証します。

#### 2. Active Modsペインの初期表示

**問題:**
アプリケーション起動時、`Active Mods`ペインには何も表示されず、MODを有効化したときに初めて項目が追加されます。これでは、現在どのMODが有効になっているのかを起動時に確認できません���

**解決策の比較:**

*   **案A: 起動時にファイルシステムをスキャンする**
    *   **方法:** アプリケーション起動時に、現在のプロファイルの `mods` ディレクトリ（例: `.cataclysm-launcher-brick/sandbox/NewProfile1/mods`）をスキャンし、存在するシンボリックリンクの一覧から有効なMODリストを生成してUIに表示します。
    *   **長所:**
        *   ファイルシステムが常に真実の状態（Source of Truth）となるため、信頼性が高いです。
        *   手動でのMOD操作など、外部での変更も正しく反映されます。
        *   状態を管理するための追加ファイルが不要で、実装が比較的シンプルです。
    *   **短所:**
        *   起動時に毎回ファイルI/Oが発生しますが、MODの数が極端に多くない限り、パフォーマンスへの影響は無視できます。

*   **案B: 有効化したMODの情報をファイルに保存する**
    *   **方法:** MODを有効化した際に、その情報を設定ファイルなどに記録します。起動時はそのファイルを読み込んで状態を復元します。
    *   **長所:**
        *   ファイルI/Oが少なく、理論上は高速です。
    *   **短所:**
        *   ファイルシステムの状態と記録した情報が乖離するリスクがあり、状態の不整合が起こり得ます。
        *   状態管理のためのファイルの読み書きやエラーハンドリングが追加で必要になり、実装が複雑化します。

**結論:**
堅牢性と実装のシンプルさから、**案A（起動時にファイルシステムをスキャンする）** を採用します。

### 実装方針

1.  **`src/ModHandler.hs` の修正:**
    *   `enableMod` 関数に、シンボリックリンクの存在チェック処理を追加します。
    *   `listActiveMods :: FilePath -> IO [ModInfo]` という、指定されたプロファイルで有効になっているMODのリストを返す新しい関数を実装します。この関数は、`mods` ディレクトリ内のシンボリックリンクをスキャンして動作します。

2.  **アプリケーション初期化処理の修正:**
    *   `app/Main.hs` または `app/Events.hs` で、アプリケーションの初期状態を構築する際に `listActiveMods` を呼び出し、その結果を `AppState` に格納するようにします。
